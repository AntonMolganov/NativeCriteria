:linkcss:
:toc: left
:source-highlighter: coderay
:last-update-label!:
:author: Przemys≈Çaw Nowak, Kamil Jasek
:date: May 30, 2017

= NativeCriteria documentation
{author}
3.0, {date}

Ultra lightweight library to generate dynamic SQL based on hibernate session


image:https://travis-ci.org/pnowy/NativeCriteria.svg?branch=develop[Build status,window="_blank", link=https://travis-ci.org/pnowy/NativeCriteria]
image:https://maven-badges.herokuapp.com/maven-central/cz.jirutka.rsql/rsql-parser/badge.svg[Maven Central, window="_blank", link=https://maven-badges.herokuapp.com/maven-central/com.github.pnowy.nc/nativeCriteria-core]

== Main advantages / assumptions

 * simple, friendly API
 * without any other generated classed based on database schema (no more fights with always problematics metamodels)
 * possibility to build complex joins with detailed projections
 * work on all databases supported by Hibernate
 * designed for a select queries (not supported update queries now)
 * separate module for spring integration (Spring Pageable abstraction support)
 * set of mappers for simple result transformations
 * support custom SQL query parts
 * separate test module with examples build on top of JPA & Spring Boot

*Available on Maven Central Repository*

[source,xml]
----
<!-- core module -->
<dependency>
    <groupId>com.github.pnowy.nc</groupId>
    <artifactId>nativeCriteria-core</artifactId>
    <version>3.0</version>
</dependency>

<!-- spring integration module -->
<dependency>
    <groupId>com.github.pnowy.nc</groupId>
    <artifactId>nativeCriteria-spring</artifactId>
    <version>3.0</version>
</dependency>
----

//See the example module with Spring Boot usage.footnote:[I am footnote text and will be rendered at the bottom of the article.]

== Design

*TODO* Describe that we are using Hibernate Session, etc.

*TODO* [See working examples with Spring Boot on separate test module](https://github.com/pnowy/NativeCriteria/tree/develop/nativeCriteria-test)

image::./images/DB_SCHEMA.png[role="center"]

== Basic examples

.Simple select
[source,java]
----
// SELECT a.city FROM address a WHERE a.zip_code IS NULL ORDER BY a.city ASC
NativeCriteria nc = new NativeCriteria(new JpaQueryProvider(entityManager), "address", "a") // <1>
      .setProjection(NativeExps.projection().addProjection("a.city"))                       // <2>
      .add(NativeExps.isNull("a.zip_code"));                                                // <3>
      .setOrder(NativeExps.order().add("a.city", OrderType.ASC));                           // <4>
// get the results
CriteriaResult res = c.criteriaResult();                                                    // <5>
List<String> cityNames = new ArrayList<>();
while (res.next()) {                                                                        // <6>
   resp.add(res.getString("a.city"));                                                       // <7>
}
----
<1> Definition of the criteria. The first parameter is a query provider. It could be JPA or HibernateSession provider
<2> Definition of the projection. We use here the alias for main table defined on the (1)
<3> Added example criteria (zip code is null)
<4> Added ordering
<5> Generate criteria result (this is the moment when query is executed)
<6> Retrieve results on the loop (there are predefined mappers, you will see more on next chapters)
<7> Retrieve string value from results and add to response

.Simple select with inner join
[source,java]
----
// SELECT s.id as supplierId, a.city as supplierCity
// FROM supplier s
// INNER JOIN address a ON s.id=a.supplier_id
NativeCriteria c = new NativeCriteria(new JpaQueryProvider(entityManager), "supplier", "s")
      .addJoin(NativeExps.innerJoin("address", "a", "s.id", "a.supplier_id"))
      .setProjection(NativeExps.projection().addProjection("s.id as supplierId","a.city as supplierCity")));
----

.Fetch count
[source,java]
----
// SELECT s.id as supplierId, a.city as supplierCity
// FROM supplier s INNER JOIN address a ON s.id=a.supplier_id
NativeCriteria nc =  new NativeCriteria(new JpaQueryProvider(entityManager), "ADDRESS", "a").add(NativeExps.eq("a.city", "Warsaw"));
int i = nc.fetchCount("a.city");
----

.Select top rows (LIMIT/OFFSET query part)
[source,java]
----
NativeCriteria nc = createNativeCriteria("ADDRESS", "a")
        .setOrder(NativeExps.ascOrder("a.id"))
        .setLimit(2)
        .setOffset(1);
List<Address> addresses = nc.criteriaResult(Address.NATIVE_OBJECT_MAPPER);
----

.Custom SQL query part
[source,java]
----
NativeCriteria nc = createSpringNativeCriteria("SUPPLIER", "s")
                    .addJoin(NativeExps.customSql("JOIN ADDRESS a ON a.supplier_id=s.id"));
 CriteriaResult result = nc.criteriaResult();
 while (result.next()) {
    String currentRecordDesc = result.getCurrentRecordDesc();
    log.info(currentRecordDesc);
}
----

TIP: See the mappers for convenient retrieving the data

== Mappers

.Get result as object list by NativeObjectMapper
[source,java]
----
//SELECT a.* FROM address
NativeCriteria nc = new NativeCriteria(new HibernateQueryProvider(session), "ADDRESS", "a")
                        .add(NativeExps.eq("a.city", "WARSAW"));
List<Address> res = nc.criteriaResult(cr -> {
    Address a = new Address();
    a.setId(cr.getLong(0));
    a.setCity(cr.getString(1));
    a.setStreet(cr.getString(2));
    a.setBuildingNumber(cr.getString(3));
    a.setZipCode(cr.getString(4));
    return a;
});
----

TIP: You could always define the mapper as separate object:

[source,java]
----
NativeCriteria nc = createNativeCriteria("ADDRESS", "a").add(NativeExps.eq("a.city", "Warsaw"));
List<Address> res = nc.criteriaResult(Address.NATIVE_OBJECT_MAPPER);
----

.Get any result by CriteriaResultTransformer
[source,java]
----
NativeCriteria nc = new NativeCriteria(new HibernateQueryProvider(session), "ADDRESS", "a");
Multimap<String, String> zipCodesGroupedByCities = nc.criteriaResult(new CriteriaResultTransformer<Multimap<String,String>>() {
    @Override
    public Multimap<String, String> transform(CriteriaResult criteriaResult) {
        Multimap<String, String> result = HashMultimap.create();
        while (criteriaResult.next()) {
            // 1 - city code, 4 - zip code
            result.put(criteriaResult.getString(1), criteriaResult.getString(4));
        }
        return result;
    }
});
----

TIP: See more mappers on Spring module

== Spring Data Integration

.NativeBeanPropertyMapper
[source,java]
----
public class Supplier {
    // properties, getters and setters, etc.
}

SpringNativeCriteria nc = new SpringNativeCriteria(new JpaQueryProvider(entityManager), "SUPPLIER", "s")
    .setProjection(NativeExps.projection().addProjection(
            "s.id as id",
            "s.name as name",
            "s.first_name as firstName",
            "s.last_name as lastName",
            "s.vat_identification_number as vat_identification_number"
            "s.phone_number as phonenumber",
            "s.email as email")
    .setOrder(NativeExps.order().add("s.id", NativeOrderExp.OrderType.ASC));
NativeBeanPropertyMapper<SupplierDTO> mapper = NativeBeanPropertyMapper.newInstance(SupplierDTO.class);
List<SupplierDTO> results = nc.criteriaResult(mapper);
----

.Pageable support
[source,java]
----
SpringNativeCriteria nc = new SpringNativeCriteria(new JpaQueryProvider(entityManager), "SUPPLIER", "s")
        .addJoin(NativeExps.innerJoin("ADDRESS", "a", "a.supplier_id", "s.id"));
        .setProjection(NativeExps.projection().addProjectionWithAliases(
            "s.id as id",
            "a.city as city",
            "s.name as name"
        ));

Page<SupplierWithAddress> suppliers = nc.criteriaResult("a.id", NativeBeanPropertyMapper.newInstance(SupplierWithAddress.class),
                                                         new PageRequest(0, 2, new Sort(new Sort.Order(Sort.Direction.ASC, "s.id"))));
List<SupplierWithAddress> pageContent = suppliers.getContent();
----

== Logging

.Logger to log execution sql time (available on DEBUG level). You could always enable by (the root appender will be used)

```xml
<logger name="NativeCriteriaPerformance" level="DEBUG" />
```

.If you want add additional log output (system log or separate file) configure the appender too:

```xml
<logger name="NativeCriteriaPerformance" level="DEBUG">
   <appender-ref ref="stdout" />
</logger>
```

== Release notes
 - *Release 3.0 changes*
 * Migrate to Java 8
 * Migrate from Maven to Gradle
 * Fixes

 - Release 2.1 changes
 * Better documentation

 - Release 2.0.1 changes
 * Extended CriteriaResult about blob methods (returns byte[] array)
 * Test profile for MySQL within test module and additional tests

 - *Release 2.0 changes*
 * New Spring module with Pageable support and bean property mapper
 * New test module with examples on Spring Boot and H2 in memory database
 * Possibility to use custom SQL query on each part of NativeCriteria
 * Fixed some minor bugs

  - Release 1.4 changes
  * Removed logback implementation (client can provide own logger implementation)
  * Upgraded hibernate to 4.3.8.Final & other dependencies to newer versions
  * Changed a little API (from NativeCriteria#getResultAsList to NativeCriteria#criteriaResult)
  * Integration with Travis CI

 - Release 1.3.1 changes
 * Fixed missing JOIN statement for FULL OUTER JOIN. The missing join does not work correctly on some databases

 - Release 1.3 changes:
 * Removed apache commons dependencies
 * Added OracleUnicodeDialect and SQLServerUnicodeDialect classes which supporting NVARCHAR types in older Hibernate version and newer databases (see problem descriptions at [here](http://www.tomecode.com/2012/01/08/how-to-fix-mapping-errors-in-hibernateno-dialect-mapping-for-jdbc-type-9-found-nclob-expected-nvarchar2/) and [here](http://www.componentix.com/blog/5/improved-hibernate-dialect-for-microsoft-sql-server))
 * Upgraded Google Guava dependency to 17.0
 * Upgraded Hibernate dependency to version 4.3.5.Final

 - Release 1.2 changes:
 * Added CriteriaResultTransformer interface
 * Migration to logback as logging implementation (from log4j)
